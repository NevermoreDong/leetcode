方法 2：动态规划

算法

这个问题可以通过动态规划解决。我们定义一个dp数组，其中第 
i个元素表示以下标为i的字符结尾的最长有效子字符串的长度。我们将 
dp数组全部初始化为 0 。现在，很明显有效的子字符串一定以 
‘)’结尾。这进一步可以得出结论：以 ‘(’结尾的子字符串对应的 
dp数组位置上的值必定为 0 。所以说我们只需要更新 
‘)’在 dp数组中对应位置的值。



为了求出dp数组，我们每两个字符检查一次，如果满足如下条件

1. s[i] = ')' 且 s[i-1] = '(',也就是字符串形如".....()", 我们可以推出：
dp[i] = dp[i-2] + 2
我们可以进行这样的转移，是因为结束部分的"()"是一个有效子字符串，
并且将之前有效子字符串的长度增加了 2 。

2. s[i] = ')' 且 s[i-1] = ')',也就是字符串形如".....))", 我们可以推出：
如果s[i - dp[i-1] - 1] = '(', 那么
dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]
这背后的原因是如果倒数第二个'('是一个有效子字符串的一部分（记为sub),
对于最后一个 ‘)’，如果它是一个更长子字符串的一部分，那么它一定有一个对应的 ‘(’，
它的位置在倒数第二个 ‘)’所在的有效子字符串的前面（也就是sub的前面）。
因此，如果子字符串sub 的前面恰好是'(',，那么我们就用 2加上sub的长度
(dp[i-1]) 去更新dp[i]。除此以外，我们也会把有效子字符串"(,sub,)"
之前的有效子字符串的长度也加上，也就是加上dp[i-dp[i-1]-2]

复杂度分析
时间复杂度：O(n)。遍历整个字符串一次，就可以将 dp 数组求出来。
空间复杂度：O(n) 。需要一个大小为 n 的 dp 数组



class Solution:
    def longestValidParentheses(self, s: str) -> int:
        n = len(s)
        if n == 0: return 0
        dp = [0] * n
        res = 0
        for i in range(n):
            if i>0 and s[i] == ")":
                if  s[i - 1] == "(":
                    dp[i] = dp[i - 2] + 2
                elif s[i - 1] == ")" and i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == "(":
                    dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]
                if dp[i] > res:
                    res = dp[i]
        return res












'''
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:

输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
示例 2:

输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
'''

